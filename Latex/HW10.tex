\documentclass{article}
\usepackage[russian]{babel}
\usepackage{ragged2e}

\begin{document}
\begin{flushleft}
\section{}

Пусть $dp[i][mask]$ - длина кратчайшего пути из вершины 0 в $i$ проходящий через вершины соответсвующие единицам в побитовой записи $mask$. Изначально $dp[0][1] = 0$, остальные элементы $+\infty$. Будем по очереди в порядке возрастания перебирать маски и вершины. Пусть мы находимся в состоянии $(v, mask)$. Если $\exists u: \exists e = (v \Rightarrow u), mask \& 2^u = 0$, то присвоим $dp[u][mask \bigoplus 2^u] = min(dp[u][mask \bigoplus u], dp[v][mask] + len(e))$. После перебора всех состояний $dp[0][2^n - 1]$ - длина минимального гамильтоного цикла, т.к это длина минимального пути из 0 в 0, проходящего по всем вершинам графа.

\section{}

Пусть есть последовательности $X$ и $Y$, $len(X) = m$, $len(Y) = n$, причем $m \ge n$. Будем искать LCS следующим рекурсивным алгоритмом: 

1)Разделим $X$ пополам на последовательности $x_1$ и $x_2$. Наивным способом за $O(nm)$ найдем длины LCS $x_1$ со всеми префиксами $Y$ и $reverse(x_2)$ со всеми префиксами $reverse(Y)$ (Мы можем использовать $O(n)$ памяти т.к для подсчета длины без восстановления ответа нужно хранить только те строки массива, которые нужны для подсчета следующей строки). 

2)Найдем такое $j$ ($j : [-1.. n - 1]$) что $LCS(x_1, y[0..j]) + LCS(reverse(x_2), reverse(y)[0.. n - 2 - j])$ - максимально. Если в $x_1$ есть элементы, входящие в LCS, индексы их пар в $Y$ $\le j$ (аналогично $> j$ для $x_2$). Докажем: Если сложить последовательности $LCS(x_1, y[0..j] и reverse(LCS(reverse(x_2), reverse(y)[0.. n - 2 - j]))$ мы получим общую подпоследовательность $X$ и $Y$ т.к последовательности $x_1, x_2, y[0..j], reverse(y[0.. n - 2 - j])$ попарно независимы. Рассмотрим индекс $k$ такой, что для него выполняется поставленное условие. Очевидно сложение LCS в таком случае даст LCS($X$, $Y$). Т.к сумма LCS при $j$ максимальна $\Rightarrow j = k$. Теперь, т.к мы разделили $X$ на независимые последовательности мы можем рекурсивно запустить алгоритм от ($x_1$, $y[0..j]$) и ($reverse(x_2)$, $reverse(y)[0.. n - 2 - j]$).

3) Когда на очередной итерации алгоритма $len(X) = 1$ проверим входит ли этот символ в $Y$. Если да добавим его в ответ, если нет значит на какой то итерации все элементы LCS оказались в противополжной половине последовательности.

4)Докажем асимптотику: глобальные последовадовательности требуют $O(n + m)$ памяти (для подсчета динамики также можно использовать один глобальный массив памяти, т.к на каждой итерации мы считаем ее отдельно и независимо). Затраты памяти для отдельной итерации - $O(1)$, всего итераций - $O(\log{m}) \Rightarrow O(\log{m})$ памяти $\Rightarrow$ всего $O(n + m)$ памяти. 

Затраты по времени: Глубина рекурсии - $O(\log{m})$. На каждом уровне алгоритм совершает $\sum\limits_{i = 0}^{2^h - 1}{\frac{m}{2^h} \cdot len(x_i)} = \frac{m}{2 ^h} \cdot \sum\limits_{i = 0}^{2^h - 1}{len(x_i)} = \frac{n \cdot m}{2^h}$.  Сумма всех операций будет равна $\sum\limits_{h = 0}^{\log{m}}{\frac{n \cdot m}{2 ^ h}} = O(nm)$

\section{}



\section{}

Пусть $dp[i][mask]$ - количество путей из $first(mask)$ ($first(mask)$ - номер наименьшего ненулевого бита маски) в $i$. Тогда изначально $dp[i][2^i] = 1$. Переберем в порядке возрастания маски и вершины. Если в состоянии $(v, mask) \exists u: u > first(mask), \exists E(v, u)$, тогда $dp[u][mask \bigoplus 2^u] += dp[v][mask]$. Предподсчет - $O(2^n \cdot n^2)$. Теперь ответом будет $\sum\limits_{count(mask) \ge 3}{\sum\limits_{i = first(mask) + 1}^{mask \& i = 1 | \exists E(first(mask), i)}{dp[i][mask]}}$ 

(Время подсчета ответа - $O(2^n \cdot n)$)

\end{flushleft}
\end{document}