\documentclass{article}
\usepackage[russian]{babel}
\usepackage{ragged2e}

\begin{document}
\begin{flushleft}

\section{}

Будем проверять позиции $2 ^ i$ пока не найдем максимальное $i$ при котором $a[2 ^ i] <= x$. Обозначим $p = 2 ^ i$ тогда для $j$ от $i - 1$ до $0$ будем проверять $a[p + 2 ^ j]$ и присваивать $p = p + 2 ^ j$ если $a[p + 2 ^ j] <= x$. Таким образом мы найдем искомое $p$ за $2 * \log{p}$ действий $\Rightarrow O(\log{p})$.

\section{}

Заведем массив $ct$ размера $n$, два указателя $l$ и $r$ (изначально 0), а также переменную $c = 0$. Будем двигать указатель $r$ вправо, принимая новое значение прибавляем 1 к $c$ если $a[r] == 0$, после прибавляем 1 к $a[r]$. Если на очередной итерации $c = k$ прибавляем к ответу 1. Когда $c > k$ двигаем границу $l$ вправо, обновляя значения следующим образом: отнимаем 1 от $a[l]$ если после этого $a[l] == 0$ отнимаем 1 от $c$, и так пока $c > k$. Проверки и смены значений на каждой итерации работают за $O(1)$, итераций будет $2 * n \Rightarrow O(n)$.

\section{}

Обозначим $n = min(n, m), m = max(n, m)$. Пусть массив длинны $n$ -- $a$, $m$ -- $b$. Запустим бин поиск по массиву $a$, который найдет максимальное количество элементов массива $a$, которые могут быть в первых $k$ элементах отсортированного обьединенного массива. Проверяя очередной $x$ можно утверждать что $x$ больше искомого значения если $b[k - x] < a[x - 1]$ (элемент, который мы не взяли из $b$ <<лучше>>, чем взятый из $a$). После того как мы найдем искомый $x$ ответом на задачу будет $max(a[x - 1], b[k - x - 1]$. Бин поиск по массиву $a$ работает за $O(\log{n}) = O(\log{min(n, m)})$

\end{flushleft}
\end{document}