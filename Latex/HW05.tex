\documentclass{article}
\usepackage[russian]{babel}
\usepackage{ragged2e}

\begin{document}
\begin{flushleft}

\section{}

Предположим существует сеть в которой нет компаратора между $i$ и $i + 1$. Если мы подадим в такую сеть массив, в котором все элементы кроме $a[i]$ и $a[i + 1]$ стоят в отсортированном порядке, тогда массив не отсортируется, так как любые компараторы кроме $i - (i + 1)$ не произведут обмен, а компаратор $i - (i + 1)$ отсутсвует $\Rightarrow$ невозможно построить такую сеть.

\section{}

Рассмотрим перемещения нашего элемента. Обозначим случай когда после выполнения слоя элемент перемещается за 1, и случай без перемещения за 0. Очевидно что последовательность 0 и 1 строго кодирует позицию, в которой окажется элемент $\Rightarrow$ чтобы сеть компараторов работала корректно при любых входных данных необходимо $n$ возможных последовательностей $\Rightarrow$ $\log_2{n}$ слоев компараторов.

\section{}

Понадобится $1$ дополнительный слой, в котором для $i$ от $1$ до $n$ проведем компаратор с $i$ на $2n - i + 1$. (Таким образом, если существует $k$ элементов в $1..n$, которые должны быть в $n + 1...2n$ они лежат с $n - k + 1$ по $n$, а $k$ элементов с которыми они должны поменяться местами лежат с $n + 1$ по $n + k \Rightarrow$ они все окажутся в нужных половинах т.к наибольше из $1..n$ сравнивают с наименьшими из $n + 1..n + k$ по порядку).

\section{}

Заведем условный массив $d$ из $n$ элементов. Изначально $d[i] = i$. Далее будем строить сортирующую сеть. Если в исходной сети встречается обычный компаратор из $i$ в $j$ просто добавим в нашу сеть компаратор из $d[i]$ в $d[j]$. Если мы встретели антикомпаратор из $i$ в $j$, добавим компаратор из $d[i]$ в $d[j]$ и поменяем значения $d[i]$ и $d[j]$. Таким образом, тот элемент, который должен был оказаться в проводе значения $d[i]$ до изменения. окажется в значении $d[i]$ после изменения и далее мы будем проводить компараторы именно к нему. Элементы встанут в нужные места после того, как пройдут через обычный компаратор, а так как сеть сортирующая, то невозможно такое чтобы конечная позиция элемента была получена антикомпаратором т.к он нарушает порядок элементов $\Rightarrow$ в итоге в случае корректности исходной сети наша сеть тоже будет корректна.

\section{}



\end{flushleft}
\end{document}