\documentclass{article}
\usepackage[russian]{babel}
\usepackage{ragged2e}

\begin{document}
\begin{flushleft}
\section{}

$f(n) = !(n - 1)$. Пускай мы выбираем позицию для элемента 1, мы можем поставить его куда угодно кроме 1 $\Rightarrow$ (n - 1) вариант. Для следующих элементов верно следующее:

1)Если при выборе места для $i$ элемента позиция $i$ не занята, то вариантов - $(n - i)$.

2)Если какой то элемент $j$ занял позицию $i$, это означает что позиция $j$ недоступна $\Rightarrow$ вариантов все равно (n - i) (Если позиция $j$ в свою очередь занята элементом $k$, то запрещена будет позиция $k$ и т.д по индукции)

\section{}

Для $n = 1$ такая перестановка одна (единственное число 1). Далее для следующих $n$: $f(n) = !(n - 1)$. Получить требуемую перестановку можно взяв валидную перестановку для $n - 1$ и добавив элемент $n$ на любую позицию кроме $n$

\section{}



\section{}

Отсортируем отрезок из первых $2k$ элементов используя любую сортировку за $O(n\log{n})$ (например MergeSort). Т.к все элементы нахоядтся не дальше чем $k$ от своей позиции, первые $k$ элементов будут расположены на нужных местах, далее мы можем повторить это для элементов с $k$ по $3k$ и т.д. Каждая сортировка будет работать за $O(k\log{k})$, количество итераций - $\frac{n}{k} \Rightarrow$ общее время работы: $\frac{n}{k} \cdot k\log{k} = O(n\log{k})$

\section{}

Рассмотрим два случая:

1)$m >= n$

$O(n \log{n}) = O(n\log{m}) \Rightarrow$ мы можем отсортировать массив $a$ за $O(n \log{n})$ и отвечать на запросы из массива $p$ за $O(1) \Rightarrow$ ответим на все запросы за $O(m) \Rightarrow$ общее время - $O(n\log{m} + m)$.

2)$m < n$

$O(m \log{m}) = O(n\log{m}) \Rightarrow$ мы можем отсоритровать массив $p$ за $O(m\log{m})$. Далее будем производить итерации Quick Sort. В среднем каждая итерация будет делить массив на две равные части, часть запросов будет относится к левой части, а часть к правой (разделить запросы можно будет за $O(\log{m})$  c помощью бин поиска по массиву $p$ ($O(\log{m}) = O(n) \Rightarrow$ время работы одной итерации останется $O(n)$)). Т.к каждая итерация делит исходный массив в среднем на две равные части, то и массив запросов так же будет делиться в среднем на 2 $\Rightarrow$ мы сможем разделить все вопросы за $O(\log{m})$ итераций $\Rightarrow$ общее время работы - $O(n \log{m})$. 

\section{}


Построим массив префикс-сумм $p$. Ответом на задачу будет количество таких пар $i, j: i < j \cup p[j] - p[i] >= k$. Попробуем найти все такие пары для $1 <= i <= n / 2 \cup n / 2 + 1 <= j <= n$. Отсортируем левую и правую половину массива $p$. Тогда методом двух указателей мы сможем найти все такие $i, j$ за $O(n)$. Далее мы можем рекурсивно запуститься от массиво с 1 по $n / 2$ и $n / 2 + 1 $ по $n$ и найти ответ для них. Количество итераций - $O(\log{n}) \Rightarrow$ общее время работы $O(n \log{n})$ (Сортировку массивов мы будем проводить параллельно с подсчетом ответа с помощью Merge Sort, который вызывается от тех же отрезков что нужны нам для поиска ответа $\Rightarrow$ времени работы алгоритма он не увеличит).
\end{flushleft}
\end{document}