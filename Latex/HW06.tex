\documentclass{article}
\usepackage[russian]{babel}
\usepackage{ragged2e}

\begin{document}
\begin{flushleft}
\section{}

Заведем кучу, хранящую индексы элементов и их детей в исходной куче  (сравнение элементов будет происходить по значениям элементов в исходной куче). Изначально положим в нее 0-ой элемент исходной кучи. Далее $k$ раз проделаем следующий алгоритм: достанем из нашей кучи минимальный элемент (он же будет $i$-ым минимумом в исходной куче), после чего положим в кучу двух детей элемента, который мы достали, таким образом после каждой итерации алгоритма мы можем быть уверены, что $(i + 1)$-й минимум исходной кучи лежит в нашей. Очевидно, что на $k$-ой итерации мы получим $k$-ый минимум. Одна итерация работает за логарифм от размера кучи $\Rightarrow$, т.к размер кучи всегда $\le k$ работает за $O(\log{k})$ $\Rightarrow$ весь алгоритм работает за $O(k \cdot \log{k})$.

\section{}

Для каждой вершины заведем переменную $d$, храняющую информацию о сумме $x$, которые прибавили к поддереву этой вершины. Тогда значением в вершине будет сумма значения в ней и всех $d$ на пути из корня в вершину (сравнивать вершины также стоит по этим новым значениям) . Чтобы не нарушать корректность кучи при изменении ее структуры заведем операцию push, которая будет передавать значение $d$ из вершины в ее детей (прибавит $d$ вершины к значению вершины и к $d$ ее детей после чего обнулит $d$ вершины). При вызове extracrt-min просто вызовем push от корня. В операции merge будем вызывать push от $x$ и $y$ на каждой итерации. Таким образом мы потратили $O(1)$ доп. памяти для каждой вершины, ассимптотика исходных операций не изменена. Прибавление $x$ также работает за $O(1)$.

\section{}

Заведем переменную $m$, которая будет хранить медиану. Также заведем две кучи $l$ и $r$ (для элементов $\le m$ и $\ge m$ соответственно, размеры куч не должны различаться более чем на 1, причем $size(r) \ge size(l)$ ) . В левой куче на вершине будет лежать максимум, а в правой минимум. Операции будут реализованны следующим образом:

1) Добавим элемент в соответсвующую ему кучу. Если после этого $size(l) > size(r)$, извлечем верхний элемент $l$ и сделаем его медианой (старую медиану добавим в кучу $r$).  В случае $size(r) - size(l) = 2$ проведем аналогичную операцию для кучи $r$. Время работы $O(\log{n})$

2) Вернем элемент $m$. Время работы $O(1)$.

3) В случае если $size(r) > size(l)$ извлечем корень $r$, иначе корень $l$. Извлеченный элемент станет новой медианой, старую удалим. Время работы $O(\log{n})$.

Построение: за $O(n)$ найдем медиану массива и присвоим $m$ медиане. Далее определим какие элементы будут лежать в левой куче, а какие в правой. В начале определим элементы $< m$ и $> m$, после чего распределим элементы $= m$ так, чтобы поддерживать условия $size(r) \ge size(l)$ и $size(r) - size(l) \le 1$. После чего воспользуемся алгоритмом построения куч за линейное время.

\section{}



\end{flushleft}
\end{document}